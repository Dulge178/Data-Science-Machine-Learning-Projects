# -*- coding: utf-8 -*-
"""EPL predictor ML

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tzymsrULaCS8ZV-sQVmPTRGX-2ukAQ_S
"""

from datetime import date
import pandas as pd
matches = pd.read_csv('matches.csv', index_col=0)
matches.head()#returns first 5 rows of data
matches.shape #(x,y) indicates x:number of columns and y:number of rows
38 * 20 * 2 # calculates numerical data for 38 teams playing 20 games over two seasons
#this returns 1520 but we only have 1389 games as represented by the shape function
matches["team"].value_counts()#returns number of games for each team
#based on EPL, we should expect 6 teams to have irregular values
#odd that there are 7
#create function to check liverpool, they should not have irregular value but do
matches[matches["team"] == "Liverpool"]#selects rows where the team is liverpool
#returns data is missing for one of the seasons,lets us know why data is missing
matches["round"].value_counts()#returns match week each match was played
#we can see how many rows/matches we have for each matchweek
#39 is expected, because we are missing liverpool, 1 less match for each matchweek
#many matchweeks have fewer than 39, some data was scraped mid-season
#just explains where missing rows went, data can still be utilized

#TIME FOR DATA CLEANUP

matches.dtypes #check the data type per each column
#ml algorithims can only work with numerical data in floats or integers
#ml can not work with objects, so we need to convert them
#for example, chaging the data can allow for properties to be extracted and
#observed
matches["date"] = pd.to_datetime(matches["date"])#doesn't create new column
#converts existing column to date time and overwriting existing column
#with date time
matches.dtypes#we can observe that the date is now a date time
#helps with computing predictors based on date time column

#CREATING BASIC PREDICTORS FOR ML MODEL!!!!:

matches["venue_code"] = matches["venue"].astype("category").cat.codes
#converts it to categorical data type in pandas and then into integers by
#using the .cat.codes function
#converts string to categories and categories to numbers
matches #creates venue code column by which = 1 when team is home and 0 when away
#home or away game can have an effect due to homefield advantage
matches["opp_code"] = matches["opponent"].astype("category").cat.codes
#same thing as venue column, produces code for each opponent
matches
matches["hour"] = matches["time"].str.replace(":.+","", regex = True).astype("int")
#generating function to remove the colon and hour from the time column with string expression
#replaces the colon and minutes portion with nothing
#then uses astype to convert the hour to an integer
#this is used to measure how teams perform based on the time of the day
matches["day_code"] = matches["date"].dt.dayofweek
#generates number for each day of week, sunday coded as 6, sat coded as 5

#WE NEED TO SET UP A TARGET: WHETHER THE TEAM WON OR NOT!!

matches["target"] = (matches["result"] == "W").astype("int")
#predict if team won or not, code W as 1 and L or D as 0
matches

#Time to train model, import

from sklearn.ensemble import RandomForestClassifier
#random forest is a model that can pick up non linearities in the data
#opponent code is not linear data, not correlation

rf = RandomForestClassifier(n_estimators=50, min_samples_split=10, random_state=1)
#n estimators is the number of decision trees we want to train
#in a random forest, each decision tree has different parameters
#higher the number n, longer algorithim will take to run, but possibly more accurate
#min_samples_split is number of samples we want in a leaf of decision tree before node split
#higher this is, less likely to overfit but lower accuracy on training data
#setting a random state makes random forest produce same results such that data is the same

#splitting training and time data:

train = matches[matches["date"] < '2022-01-01']
#takes all matches before 2022 and inputs into data set
#data is time series, data must be split so all data in test set comes after training set
#you can only predict future data using past

test = matches[matches["date"] > '2022-01-01']
#test set is data after 2022

predictors = ["venue_code", "opp_code", "hour", "day_code"]
# list of codes we created
rf.fit(train[predictors], train["target"])
#.fit method trains random forest model with predictors trying to predict target
#target is 0 if team loses or draws and 1 if they win
preds = rf.predict(test[predictors])
# generate predictions using predict method, pass in test data and predictors

#!WE NEED TO DETERMINE THE ACCURACY OF THE MODEL! VERY IMPORTANT

from sklearn.metrics import accuracy_score
#checks if win is predicted, what % did team actually win
#checks if loss is predicted, what % did team actually lose
#combines these
acc = accuracy_score(test["target"], preds)
#pass in actuals and predictions
acc # accuracy is 61%

#we need to check in more specialized situations, when accuracy was high or low

combined = pd.DataFrame(dict(actual=test["target"], prediction=preds))
#data frame will combine actual values with predicted values
#actual is the target and predictions are just predictions

pd.crosstab(index=combined["actual"], columns=combined["prediction"])
#when we predicted loss or draw, we tend to be correct more often
#when we predict win, we are wrong more often than not
#we must revise accuracy metric since we are interested in wins

from sklearn.metrics import precision_score
#tells what percent of time when we predicted a win did team actually win
precision_score(test["target"], preds)
#returns 47% accuracy, model can be proved

#IMPROVING PRECISION WITH ROLLING AVERAGES

grouped_matches = matches.groupby("team")
#create 1 dataframe for every squad in our data
group = grouped_matches.get_group("Manchester City")
group

def rolling_averages(group, cols, new_cols):
  group = group.sort_values("date")
  rolling_stats = group[cols].rolling(3, closed='left').mean()
  group[new_cols] = rolling_stats
  group = group.dropna(subset=new_cols)
  return group
#create function to take a group and take a set of columns to compute rolling averages for
#and take a set of new columns that we want to assign rolling averages to
#sort group by date in ascending order of date to observe performance in previous matches
#rolling_stats takes a set of colums in list cols and compute rolling averages for those
#closed='left' parameter is very important
#if not passed, pandas will compute rolling average for 3 weeks and
# then assign that average to week 3
#closed=left takes current week out when observing these averages and looks at past 3 weeks
#assign rolling stats back to original dataframe with new names
#then drop any missing values, dropna removes all rows with missing values
#many ml models can not deal with missing values

cols = ["gf", "ga", "sh", "sot", "dist", "fk", "pk", "pkatt"]
#columns we want to compute rolling averages for
#goals for, goals against, shots, shots on target, distance, free kicks, penalty kicks, penalty kick attempts
new_cols = [f"{c}_rolling" for c in cols]#format string

new_cols
rolling_averages(group, cols, new_cols)
#call rolling averages for a single group
#adds in extra colums about what happened in previous 3 matches
#pass values into ml algorithim to improve accuracy
matches_rolling = matches.groupby("team").apply(lambda x: rolling_averages(x, cols, new_cols))
#calling apply, will apply the rolling averages function to each team
#pass in columns and new columns
matches_rolling
#took original matches dataframe and grouped it by team
#lambda function is an anonymous small function with no name
#creates one data frame for each team in our data and applied rolling average function for each team
#we now have rolling averages for every match

#every team name is a separate level to pandas index, not necessary
#drop index level for ease

matches_rolling = matches_rolling.droplevel('team')
matches_rolling

#we have 1317 rows, but index does not reach that number meaning values are being repeated
#we want unique values in index so call:

matches_rolling.index = range(matches_rolling.shape[0])
matches_rolling
#assign values from 0 to 1316 to be new indices
#gives unique values for each index

#RETRAINING ML MODEL

#we have new predictors and can make a new set of predictions
def make_predictions(data, predictors):
  train = data[data["date"] < '2022-01-01']
  test = data[data["date"] > '2022-01-01']
  rf.fit(train[predictors], train["target"])
  preds = rf.predict(test[predictors])
  combined = pd.DataFrame(dict(actual=test["target"], prediction=preds), index=test.index)
  precision = precision_score(test["target"], preds)
  return combined, precision
  #copy and paste previous code and input into function so it can be used
combined, precision = make_predictions(matches_rolling, predictors + new_cols)
#call function, pass in our predictors and add new predictors which are in new cols
precision #improved: 47% to 62.5%
combined
#combined doesn't specify which team, so if we add in team info it will fix issue
combined = combined.merge(matches_rolling[["date", "team", "opponent", "result"]], left_index=True, right_index=True)
#pandas will look in combined data frame, determine index for row, and find corresponding index in
#matches rolling and merge row based on this data.
combined

#combining home and away predictions
#look at how algorithim did at predicting both sides
#we have data for both teams, home and away
#algorithim could have predicted that one team would win and other team would also win
#we can observe the prediction for Arsenal and Burnley
#by combining these two, we can dig deeper


class MissingDict(dict):#team name and opponent name differ, wolverhampton wanderers listed as wolves
#needs to be normalized so names are conistent, create dictionary and use pandas map function
#by default, the pandas map method will not handle any missing keys
#if we create a mapping dictionary missing a team name, it will remove that team name
#instead we want to replace it with the original team name passed in
  __missing__ = lambda self, key: key

map_values = {"Brighton and Hove Albion": "Brighton",
                "Manchester United": "Manchester Utd",
                "Newcastle United": "Newcastle Utd",
                "Tottenham Hotspur": "Tottenham",
                "West Ham United": "West Ham",
                "Wolverhampton Wanderers": "Wolves"

  }
mapping = MissingDict(**map_values)
#create mapping dictionary
mapping["Arsenal"]
#Returns Arsenal
mapping["West Ham United"]
#returns West Ham

#use this in pandas map method

combined["new_team"] = combined["team"].map(mapping)
#creates new team field in combined dictionary which is same dictionary in opponent field
#can be used to merge data frame with itself

merged = combined.merge(combined, left_on=["date", "new_team"], right_on=["date", "opponent"])
#one row says team arsenal with opponet burnley
#another row says team burnley with opponent arsenal
#we merge to check if the prediction values are the same
#looks for new team field and merge with opponent field on other side
merged[(merged["prediction_x"] == 1) & (merged["prediction_y"] == 0)]["actual_x"].value_counts()
#look at all rows where one team was predicted to win and other team was predicted to lose
#predicted x = 1 means team 1 predicted to win, predicted y = 0 means team 2 predicted to lose
#actual x observes what actually happened
#27/40 = 67.5% precision

#best way to extend and improve accuracy is get data for more seasons
#we can also use some of the other columns

